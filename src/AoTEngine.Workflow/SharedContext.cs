namespace AoTEngine.Workflow;

/// <summary>
/// Represents a shared context (blackboard) that all tasks can read and update.
/// This enables task coordination by storing intermediate results, code artifacts,
/// and shared knowledge that subsequent tasks can access.
/// </summary>
public class SharedContext
{
    /// <summary>
    /// The original user request.
    /// </summary>
    public string OriginalRequest { get; set; } = string.Empty;

    /// <summary>
    /// Clarified requirements gathered during the planning phase.
    /// </summary>
    public List<ClarifiedRequirement> ClarifiedRequirements { get; set; } = new();

    /// <summary>
    /// The specification document generated from requirements.
    /// </summary>
    public SpecificationDocument? Specification { get; set; }

    /// <summary>
    /// The project blueprint containing the step-by-step plan.
    /// </summary>
    public ProjectBlueprint? Blueprint { get; set; }

    /// <summary>
    /// Code artifacts generated by tasks, keyed by artifact name (e.g., interface name, class name).
    /// </summary>
    public Dictionary<string, CodeArtifact> CodeArtifacts { get; set; } = new();

    /// <summary>
    /// Intermediate results from task execution, keyed by task ID.
    /// </summary>
    public Dictionary<string, TaskResult> IntermediateResults { get; set; } = new();

    /// <summary>
    /// Global constants and configuration values shared across tasks.
    /// </summary>
    public Dictionary<string, string> GlobalConstants { get; set; } = new();

    /// <summary>
    /// Type definitions registry for tracking all types across the project.
    /// </summary>
    public Dictionary<string, TypeDefinition> TypeRegistry { get; set; } = new();

    /// <summary>
    /// Uncertainties that were identified and resolved during planning.
    /// </summary>
    public List<ResolvedUncertainty> ResolvedUncertainties { get; set; } = new();

    /// <summary>
    /// Checkpoints for tracking workflow progress.
    /// </summary>
    public List<WorkflowCheckpoint> Checkpoints { get; set; } = new();

    /// <summary>
    /// Adds a code artifact to the shared context.
    /// </summary>
    public void AddCodeArtifact(string name, CodeArtifact artifact)
    {
        CodeArtifacts[name] = artifact;
    }

    /// <summary>
    /// Gets a code artifact by name, or null if not found.
    /// </summary>
    public CodeArtifact? GetCodeArtifact(string name)
    {
        return CodeArtifacts.TryGetValue(name, out var artifact) ? artifact : null;
    }

    /// <summary>
    /// Registers a type definition in the shared context.
    /// </summary>
    public void RegisterType(TypeDefinition typeDefinition)
    {
        TypeRegistry[typeDefinition.FullyQualifiedName] = typeDefinition;
    }

    /// <summary>
    /// Gets relevant context for a specific task based on its dependencies.
    /// </summary>
    public string GetContextForTask(string taskId, List<string> dependencies)
    {
        var contextBuilder = new System.Text.StringBuilder();

        // Add clarified requirements relevant to this task
        contextBuilder.AppendLine("=== Clarified Requirements ===");
        foreach (var req in ClarifiedRequirements)
        {
            contextBuilder.AppendLine($"- {req.Question}: {req.Answer}");
        }

        // Add specification summary if available
        if (Specification != null)
        {
            contextBuilder.AppendLine();
            contextBuilder.AppendLine("=== Specification Summary ===");
            contextBuilder.AppendLine(Specification.Summary);
        }

        // Add code artifacts from dependencies
        if (dependencies.Any())
        {
            contextBuilder.AppendLine();
            contextBuilder.AppendLine("=== Code from Dependencies ===");
            foreach (var depId in dependencies)
            {
                if (IntermediateResults.TryGetValue(depId, out var result))
                {
                    contextBuilder.AppendLine($"// From task: {depId}");
                    contextBuilder.AppendLine(result.GeneratedCode);
                    contextBuilder.AppendLine();
                }
            }
        }

        // Add known types for reference
        if (TypeRegistry.Any())
        {
            contextBuilder.AppendLine();
            contextBuilder.AppendLine("=== Known Types (DO NOT REDEFINE) ===");
            foreach (var type in TypeRegistry.Values)
            {
                contextBuilder.AppendLine($"// {type.Kind}: {type.FullyQualifiedName}");
                if (!string.IsNullOrEmpty(type.Signature))
                {
                    contextBuilder.AppendLine(type.Signature);
                }
            }
        }

        return contextBuilder.ToString();
    }

    /// <summary>
    /// Creates a checkpoint of the current workflow state.
    /// </summary>
    public WorkflowCheckpoint CreateCheckpoint(string phaseName, string status)
    {
        var checkpoint = new WorkflowCheckpoint
        {
            Id = Guid.NewGuid().ToString(),
            PhaseName = phaseName,
            Status = status,
            CreatedAtUtc = DateTime.UtcNow,
            CompletedTaskIds = IntermediateResults.Keys.ToList(),
            ArtifactCount = CodeArtifacts.Count,
            TypeCount = TypeRegistry.Count
        };

        Checkpoints.Add(checkpoint);
        return checkpoint;
    }
}

/// <summary>
/// Represents a clarified requirement gathered during the planning phase.
/// </summary>
public class ClarifiedRequirement
{
    public string Question { get; set; } = string.Empty;
    public string Answer { get; set; } = string.Empty;
    public string Category { get; set; } = string.Empty;
    public DateTime ClarifiedAtUtc { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// Represents the specification document generated from requirements.
/// </summary>
public class SpecificationDocument
{
    public string Title { get; set; } = string.Empty;
    public string Summary { get; set; } = string.Empty;
    public List<string> FunctionalRequirements { get; set; } = new();
    public List<string> NonFunctionalRequirements { get; set; } = new();
    public List<string> Constraints { get; set; } = new();
    public List<string> Assumptions { get; set; } = new();
    public string TechnicalApproach { get; set; } = string.Empty;
    public DateTime GeneratedAtUtc { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// Represents the project blueprint - a step-by-step plan of atomic tasks.
/// </summary>
public class ProjectBlueprint
{
    public string ProjectName { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public List<BlueprintTask> Tasks { get; set; } = new();
    public List<string> Components { get; set; } = new();
    public Dictionary<string, List<string>> ComponentRelationships { get; set; } = new();
    public DateTime GeneratedAtUtc { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// Represents a task in the project blueprint.
/// </summary>
public class BlueprintTask
{
    public string Id { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public string Component { get; set; } = string.Empty;
    public List<string> Dependencies { get; set; } = new();
    public List<string> ExpectedOutputs { get; set; } = new();
    public int EstimatedLines { get; set; }
    public string AcceptanceCriteria { get; set; } = string.Empty;
}

/// <summary>
/// Represents a code artifact generated by a task.
/// </summary>
public class CodeArtifact
{
    public string Name { get; set; } = string.Empty;
    public string Code { get; set; } = string.Empty;
    public string ArtifactType { get; set; } = string.Empty; // Interface, Class, Enum, etc.
    public string Namespace { get; set; } = string.Empty;
    public string GeneratedByTaskId { get; set; } = string.Empty;
    public DateTime GeneratedAtUtc { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// Represents the result of a task execution.
/// </summary>
public class TaskResult
{
    public string TaskId { get; set; } = string.Empty;
    public string GeneratedCode { get; set; } = string.Empty;
    public bool IsValidated { get; set; }
    public List<string> ValidationErrors { get; set; } = new();
    public int AttemptCount { get; set; }
    public DateTime CompletedAtUtc { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// Represents a type definition registered in the shared context.
/// </summary>
public class TypeDefinition
{
    public string Name { get; set; } = string.Empty;
    public string Namespace { get; set; } = string.Empty;
    public string FullyQualifiedName { get; set; } = string.Empty;
    public string Kind { get; set; } = string.Empty; // Interface, Class, Enum, Struct
    public string Signature { get; set; } = string.Empty;
    public string DefinedByTaskId { get; set; } = string.Empty;
}

/// <summary>
/// Represents an uncertainty that was identified and resolved.
/// </summary>
public class ResolvedUncertainty
{
    public string Question { get; set; } = string.Empty;
    public string Resolution { get; set; } = string.Empty;
    public string Phase { get; set; } = string.Empty;
    public DateTime ResolvedAtUtc { get; set; } = DateTime.UtcNow;
}

/// <summary>
/// Represents a checkpoint in the workflow for progress tracking.
/// </summary>
public class WorkflowCheckpoint
{
    public string Id { get; set; } = string.Empty;
    public string PhaseName { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public DateTime CreatedAtUtc { get; set; } = DateTime.UtcNow;
    public List<string> CompletedTaskIds { get; set; } = new();
    public int ArtifactCount { get; set; }
    public int TypeCount { get; set; }
}
